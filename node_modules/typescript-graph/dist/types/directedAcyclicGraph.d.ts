import DirectedGraph from "./directedGraph";
/**
 * # DirectedAcyclicGraph
 *
 * A DirectedAcyclicGraph is builds on a [[`DirectedGraph`]] but enforces acyclicality. You cannot add an edge to a DirectedAcyclicGraph that would create a cycle.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
export default class DirectedAcyclicGraph<T> extends DirectedGraph<T> {
    private _topologicallySortedNodes?;
    protected hasCycle: boolean;
    /**
     * Converts an existing directed graph into a directed acyclic graph.
     * Throws a {@linkcode CycleError} if the graph attempting to be converted contains a cycle.
     * @param graph The source directed graph to convert into a DAG
     */
    static fromDirectedGraph<T>(graph: DirectedGraph<T>): DirectedAcyclicGraph<T>;
    /**
     * Adds an edge to the graph similarly to [[`DirectedGraph.addEdge`]] but maintains correctness of the acyclic graph.
     * Thows a [[`CycleError`]] if adding the requested edge would create a cycle.
     * Adding an edge invalidates the cache of topologically sorted nodes, rather than updating it.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     */
    addEdge(fromNodeIdentity: string, toNodeIdentity: string): void;
    /**
     * Inserts a node into the graph and maintains topologic sort cache by prepending the node
     * (since all newly created nodes have an [[ indegreeOfNode | indegree ]] of zero.)
     *
     * @param node The node to insert
     */
    insert(node: T): string;
    /**
     * Topologically sort the nodes using Kahn's algorithim. Uses a cache which means that repeated calls should be O(1) after the first call.
     * Non-cached calls are potentially expensive, Kahn's algorithim is O(|EdgeCount| + |NodeCount|).
     * There may be more than one valid topological sort order for a single graph,
     * so just because two graphs are the same does not mean that order of the resultant arrays will be.
     *
     * @returns An array of nodes sorted by the topological order.
     */
    topologicallySortedNodes(): Array<T>;
    /**
     * Given a starting node this returns a new [[`DirectedA`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    getSubGraphStartingFrom(startNodeIdentity: string): DirectedAcyclicGraph<T>;
}
