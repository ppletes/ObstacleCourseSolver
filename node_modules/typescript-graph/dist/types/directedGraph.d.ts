import Graph from "./graph";
/**
 * # DirectedGraph
 *
 * A DirectedGraph is similar a [[`Graph`]] but with additional functionality.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
export default class DirectedGraph<T> extends Graph<T> {
    /** Caches if the graph contains a cycle. If `undefined` then it is unknown. */
    protected hasCycle?: boolean;
    /**
     * Returns `true` if there are no cycles in the graph.
     * This relies on a cached value so calling it multiple times without adding edges to the graph should be O(1) after the first call.
     * Non-cached calls are potentially expensive, the implementation is based on Kahn's algorithim which is O(|EdgeCount| + |NodeCount|).
     */
    isAcyclic(): boolean;
    /**
     * The indegree of a node is the number of edges that point to it. This will always be an integer.
     *
     * Throws a [[`NodeDoesntExistError`]] the node does not exist.
     *
     * @param nodeID The string of the node identity of the node to calculate indegree for.
     */
    indegreeOfNode(nodeID: string): number;
    /**
     * Add a directed edge to the graph.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     * @param skipUpdatingCyclicality This boolean indicates if the cache of the cyclicality of the graph should be updated.
     * If `false` is passed the cached will be invalidated because we can not assure that a cycle has not been created.
     */
    addEdge(fromNodeIdentity: string, toNodeIdentity: string, skipUpdatingCyclicality?: boolean): void;
    /**
     * Depth first search to see if one node is reachable from another following the directed edges.
     *
     * __Caveat:__ This will return false if `startNode` and `endNode` are the same node and the is not a cycle or a loop edge connecting them.
     *
     * @param startNode The string identity of the node to start at.
     * @param endNode The string identity of the node we are attempting to reach.
     */
    canReachFrom(startNode: string, endNode: string): boolean;
    /**
     * Checks if adding the specified edge would create a cycle.
     * Returns true in O(1) if the graph already contains a known cycle, or if `fromNodeIdentity` and `toNodeIdentity` are the same.
     *
     * @param fromNodeIdentity The string identity of the node the edge is from.
     * @param toNodeIdentity The string identity of the node the edge is to.
     */
    wouldAddingEdgeCreateCyle(fromNodeIdentity: string, toNodeIdentity: string): boolean;
    /**
     * Given a starting node this returns a new [[`DirectedGraph`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    getSubGraphStartingFrom(startNodeIdentity: string): DirectedGraph<T>;
    private subAdj;
}
