{"version":3,"file":"typescript-graph.es5.js","sources":["../src/errors.ts","../src/graph.ts","../src/directedGraph.ts","../src/directedAcyclicGraph.ts"],"sourcesContent":["\n/**\n * # NodeAlreadyExistsError\n *\n * This error is thrown when trying to create a node with the same identity as an existing node.\n *\n * @category Errors\n */\n\nexport class NodeAlreadyExistsError<T> extends Error {\n  public newNode: T;\n  public oldNode: T;\n  public identity: string;\n\n  constructor(newNode: T, oldNode: T, identity: string) {\n    super(`${JSON.stringify(newNode)} shares an identity (${identity}) with ${JSON.stringify(oldNode)}`);\n    this.newNode = newNode;\n    this.oldNode = oldNode;\n    this.identity = identity;\n    this.name = \"NodeAlreadyExistsError\";\n\n    // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279\n    Object.setPrototypeOf(this, NodeAlreadyExistsError.prototype);\n  }\n}\n\n/**\n * # NodeDoesntExistError\n * This error is thrown when trying to access a node in a graph by it's identity when that node doesn't exist\n *\n * @category Errors\n */\nexport class NodeDoesntExistError<T> extends Error {\n    public identity: string;\n\n    constructor(identity: string) {\n        super(`A node with identity ${identity} doesn't exist in the graph`);\n        this.identity = identity;\n        this.name = \"NodeDoesntExistError\";\n\n        // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279\n        Object.setPrototypeOf(this, NodeDoesntExistError.prototype);\n    }\n}\n\n/**\n * # CycleError\n * \n * This error is thrown when attempting to create or update a Directed Acyclic Graph that contains a cycle.\n *\n * @category Errors\n */\nexport class CycleError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"CycleError\";\n\n        // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279\n        Object.setPrototypeOf(this, CycleError.prototype);\n    }\n}\n","import { NodeAlreadyExistsError, NodeDoesntExistError } from \"./errors\";\n\n/**\n * This is the default [[Graph.constructor | `nodeIdentity`]] function it is simply imported from [object-hash](https://www.npmjs.com/package/object-hash)\n */\nconst hash = require('object-hash');\n\n/**\n * @internal\n * This type is simply an indicator of whether an edge exists in the adjacency matrix.\n */\nexport type Edge = 1 | 0;\n\n/**\n * # Graph\n * \n * A `Graph` is is a simple undirected graph. On it's own it isn't too useful but it forms the basic functionality for the [[`DirectedGraph`]] and [[`DirectedAcyclicGraph`]].\n * \n * ## Creating a Graph\n * \n * You can create a graph to contain any type of node, for example:\n * \n * ```typescript\n * type NodeType = { a: Number, b: string }\n * const graph = new Graph<NodeType>()\n * \n * // Add a node of the defined type\n * graph.insert({ a: 10, b: 'string' })\n * ```\n * \n * ### Defining a custom node identity\n *\n * When you create a graph you likely want to create include a custom `nodeIdentity` function. \n * This function tells the graph how to uniquely identify nodes in a graph, \n * default is to simply use an [[hash]] which means that functionality like [[`replace`]] will not work.\n *\n * ```typescript\n * type NodeType = { count: number, name: string }\n * const graph = new Graph<NodeType>((n) => n.name)\n *\n * // Add a node\n * graph.insert({ count: 5, name: 'node1' })\n * // This will throw an error even though `count` is different because they share a name.\n * graph.insert({ count: 20, name: 'node1' })\n * ```\n * \n * ### Adding an edge\n * \n * Graphs without edges aren't very useful. Inserting edges is done using the node identity string returned by the node identity function.\n * \n * ```typescript\n * const node1: string = graph.insert({ count: 5, name: 'node1' })\n * const node2: string = graph.insert({ count: 20, name: 'node2' })\n * \n * graph.addEdge(node1, node2)\n * \n * // This will throw an error since there is no node with the later name.\n * graph.addEdge(node1, 'not a real node')\n * ```\n * \n * In an undirected graph the order in which you input the node names doesn't matter,\n * but in directed graphs the \"from node\" comes first and the \"to node\" will come second.\n * \n * ### Replacing a node\n * \n * If a node already exists you can update it using [[`replace`]]. `nodeIdentity(newNode)` must be equal to `nodeIdentity(oldNode)`.\n * \n * ```typescript\n * const node1: string = graph.insert({ count: 5, name: 'node1' })\n * const node2: string = graph.insert({ count: 20, name: 'node2' })\n * \n * // This will work because the name has not changed.\n * graph.replace({ count: 15, name: 'node1' })\n * \n * // This will not work because the name has changed.\n * graph.replace({ count: 20, name: 'node3' })\n * ```\n * \n * [[`replace`]] will throw a [[`NodeDoesntExistError`]] exception if you are trying to replace a node that is missing from the graph.\n * \n * ### Upsert\n * \n * Often you will want to create a node node if it doesn't exist and update it does. This can be achieved using [[`upsert`]].\n * \n * ```typescript\n * const node1: string = graph.insert({ count: 5, name: 'node1' })\n *\n * // Both of these will work, the first updating node1 and the second creating a node.\n * const node2: string = graph.upsert({ count: 15, name: 'node1' })\n * const node3: string = graph.upsert({ count: 25, name: 'node3' })\n * ```\n * \n * [[`upsert`]] always return the node identity string of the inserted or updated node. At presented there is no way to tell if the node was created or updated.\n * \n * @typeParam T  `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.\n */\nexport default class Graph<T> {\n  protected nodes: Map<string, T>;\n  protected adjacency: Array<Array<Edge>>;\n  protected nodeIdentity: (t: T) => string;\n\n  constructor(nodeIdentity: (node: T) => string = (node) => hash(node)) {\n    this.nodes = new Map();\n    this.adjacency = [];\n    this.nodeIdentity = nodeIdentity;\n  }\n\n  /**\n   * Add a node to the graph if it doesn't already exist. If it does, throw a [[`NodeAlreadyExistsError`]].\n   * \n   * @param node The node to be added\n   * @returns A `string` that is the identity of the newly inserted node. This is created by applying the [[constructor | `nodeIdentity`]].\n   */\n  insert(node: T): string {\n    const isOverwrite = this.nodes.has(this.nodeIdentity(node));\n\n    if (isOverwrite) {\n      throw new NodeAlreadyExistsError(node, this.nodes.get(this.nodeIdentity(node)), this.nodeIdentity(node))\n    }\n    \n    this.nodes.set(this.nodeIdentity(node), node)\n    this.adjacency.map(adj => adj.push(0))\n    this.adjacency.push(new Array(this.adjacency.length + 1).fill(0))\n\n    return this.nodeIdentity(node);\n  }\n\n  /**\n   * This replaces an existing node in the graph with an updated version. \n   * Throws a [[`NodeDoesNotExistsError`]] if no node with the same identity already exists. \n   * \n   * __Caveat_:_ The default identity function means that this will never work since if the node changes it will have a different [[`hash`]].\n   * \n   * @param node The new node that is replacing the old one.\n   */\n  replace(node: T) {\n    const isOverwrite = this.nodes.has(this.nodeIdentity(node));\n\n    if (!isOverwrite) {\n      throw new NodeDoesntExistError(this.nodeIdentity(node));\n    }\n\n    this.nodes.set(this.nodeIdentity(node), node)\n  }\n\n  /**\n   * This essentially combines the behavior of [[`insert`]] and [[`replace`]].\n   * If the node doesn't exist, create it. If the node already exists, replace it with the updated version.\n   * \n   * @param node The node to insert or update\n   * @returns The identity string of the node inserted or updated.\n   */\n  upsert(node: T): string {\n    const isOverwrite = this.nodes.has(this.nodeIdentity(node));\n\n    this.nodes.set(this.nodeIdentity(node), node)\n\n    if (!isOverwrite) {\n      this.adjacency.map(adj => adj.push(0))\n      this.adjacency.push(new Array(this.adjacency.length + 1).fill(0))\n    }\n\n    return this.nodeIdentity(node);\n  }\n\n  /**\n   * Create an edge between two nodes in the graph. \n   * Throws a [[`NodeDoesNotExistsError`]] if no either of the nodes you are attempting to connect do not exist.\n   * \n   * @param node1Identity The first node to connect (in [[`DirectedGraph`]]s and [[`DirectedAcyclicGraph`]]s this is the `from` node.)\n   * @param node2Identity The second node to connect (in [[`DirectedGraph`]]s and [[`DirectedAcyclicGraph`]]s this is the `to` node)\n   */\n  addEdge(node1Identity: string, node2Identity: string) {\n    const node1Exists = this.nodes.has(node1Identity)\n    const node2Exists = this.nodes.has(node2Identity)\n\n    if (!node1Exists) {\n      throw new NodeDoesntExistError(node1Identity)\n    }\n\n    if (!node2Exists) {\n      throw new NodeDoesntExistError(node2Identity)\n    }\n\n    const node1Index = Array.from(this.nodes.keys()).indexOf(node1Identity);\n    const node2Index = Array.from(this.nodes.keys()).indexOf(node2Identity);\n\n    this.adjacency[node1Index][node2Index] = 1\n  }\n\n  /**\n   * This simply returns all the nodes stored in the graph\n   * \n   * @param compareFunc An optional function that indicates the sort order of the returned array\n   */\n  getNodes(compareFunc?: (a: T, b: T) => number): T[] {\n    const temp = Array.from(this.nodes.values());\n\n    if (compareFunc) {\n      return temp.sort(compareFunc)\n    }\n\n    return temp;\n  }\n}\n","import { NodeDoesntExistError } from \"./errors\";\nimport Graph, { Edge } from \"./graph\";\n\n/**\n * # DirectedGraph\n * \n * A DirectedGraph is similar a [[`Graph`]] but with additional functionality.\n * \n * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.\n */\nexport default class DirectedGraph<T> extends Graph<T> {\n    /** Caches if the graph contains a cycle. If `undefined` then it is unknown. */\n    protected hasCycle?: boolean;\n\n    /**\n     * Returns `true` if there are no cycles in the graph. \n     * This relies on a cached value so calling it multiple times without adding edges to the graph should be O(1) after the first call.\n     * Non-cached calls are potentially expensive, the implementation is based on Kahn's algorithim which is O(|EdgeCount| + |NodeCount|).\n     */\n    isAcyclic(): boolean {\n        if (this.hasCycle !== undefined) {\n            return !this.hasCycle\n        }\n\n        const nodeIndices = Array.from(this.nodes.keys());\n        const nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(n => [n, this.indegreeOfNode(n)]))\n\n        let toSearch = Array.from(nodeInDegrees).filter(pair => pair[1] === 0)\n\n        let visitedNodes = 0;\n        \n        while (toSearch.length > 0) {\n            const cur = toSearch.pop();\n            if (!cur) {\n                continue;\n            }\n\n            const nodeIndex = nodeIndices.indexOf(cur[0]);\n            this.adjacency[nodeIndex].forEach((hasAdj, index) => {\n                if (hasAdj === 1) {\n                    const currentInDegree = nodeInDegrees.get(nodeIndices[index]);\n                    if (currentInDegree !== undefined) {\n                        nodeInDegrees.set(nodeIndices[index], currentInDegree - 1)\n                        if ((currentInDegree - 1) === 0) {\n                            toSearch.push([nodeIndices[index], currentInDegree - 1])\n                        }\n                    }\n                }\n            })\n\n            visitedNodes++;\n        }\n\n        this.hasCycle = !(visitedNodes === this.nodes.size)\n\n        return visitedNodes === this.nodes.size;\n    }\n\n    /**\n     * The indegree of a node is the number of edges that point to it. This will always be an integer.\n     * \n     * Throws a [[`NodeDoesntExistError`]] the node does not exist.\n     * \n     * @param nodeID The string of the node identity of the node to calculate indegree for.\n     */\n    indegreeOfNode(nodeID: string): number {\n        const nodeIdentities = Array.from(this.nodes.keys());\n        const indexOfNode = nodeIdentities.indexOf(nodeID);\n\n        if (indexOfNode === -1) {\n            throw new NodeDoesntExistError(nodeID);\n        }\n\n        return this.adjacency.reduce<number>((carry, row) => {\n            return carry + ((row[indexOfNode] > 0)? 1 : 0);\n        }, 0)\n    }\n\n    /**\n     * Add a directed edge to the graph.\n     * \n     * @param fromNodeIdentity The identity string of the node the edge should run from. \n     * @param toNodeIdentity The identity string of the node the edge should run to.\n     * @param skipUpdatingCyclicality This boolean indicates if the cache of the cyclicality of the graph should be updated.\n     * If `false` is passed the cached will be invalidated because we can not assure that a cycle has not been created.\n     */\n    addEdge(fromNodeIdentity: string, toNodeIdentity: string, skipUpdatingCyclicality: boolean = false) {\n        if (!this.hasCycle && !skipUpdatingCyclicality) {\n            this.hasCycle = this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity);\n        } else if (skipUpdatingCyclicality) {\n            this.hasCycle = undefined;\n        }\n\n        super.addEdge(fromNodeIdentity, toNodeIdentity)\n    }\n\n    /**\n     * Depth first search to see if one node is reachable from another following the directed edges.\n     * \n     * __Caveat:__ This will return false if `startNode` and `endNode` are the same node and the is not a cycle or a loop edge connecting them.\n     * \n     * @param startNode The string identity of the node to start at. \n     * @param endNode The string identity of the node we are attempting to reach.\n     */\n    canReachFrom(startNode: string, endNode: string): boolean {\n        const nodeIdentities = Array.from(this.nodes.keys());\n        const startNodeIndex = nodeIdentities.indexOf(startNode);\n        const endNodeIndex = nodeIdentities.indexOf(endNode);\n\n        if (this.adjacency[startNodeIndex][endNodeIndex] > 0) {\n            return true\n        }\n\n        return this.adjacency[startNodeIndex].reduce<boolean>((carry, edge, index) => {\n            if (carry || (edge < 1)) {\n                return carry;\n            }\n\n            return this.canReachFrom(nodeIdentities[index], endNode)\n        }, false)\n    }\n\n    /**\n     * Checks if adding the specified edge would create a cycle.\n     * Returns true in O(1) if the graph already contains a known cycle, or if `fromNodeIdentity` and `toNodeIdentity` are the same.\n     * \n     * @param fromNodeIdentity The string identity of the node the edge is from.\n     * @param toNodeIdentity The string identity of the node the edge is to.\n     */\n    wouldAddingEdgeCreateCyle(fromNodeIdentity: string, toNodeIdentity: string): boolean {\n        return this.hasCycle || fromNodeIdentity === toNodeIdentity || this.canReachFrom(toNodeIdentity, fromNodeIdentity);\n    }\n\n    /**\n     * Given a starting node this returns a new [[`DirectedGraph`]] containing all the nodes that can be reached. \n     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.\n     * \n     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.\n     */\n    getSubGraphStartingFrom(startNodeIdentity: string): DirectedGraph<T> {\n        const nodeIndices = Array.from(this.nodes.keys());\n        const initalNode = this.nodes.get(startNodeIdentity)\n\n        if (!initalNode) {\n            throw new NodeDoesntExistError(startNodeIdentity);\n        }\n\n        const recur = (startNodeIdentity: string, nodesToInclude: T[]): T[] => {\n            let toReturn = [...nodesToInclude];\n            const nodeIndex = nodeIndices.indexOf(startNodeIdentity);\n            this.adjacency[nodeIndex].forEach((hasAdj, index) => {\n                if (hasAdj === 1 && !nodesToInclude.find(n => this.nodeIdentity(n) === nodeIndices[index])) {\n                    const newNode = this.nodes.get(nodeIndices[index])\n                    \n                    if (newNode) {\n                        toReturn = [...recur(nodeIndices[index], toReturn), newNode]\n                    }\n                }\n            })\n\n            return toReturn;\n        }\n\n        const newGraph = new DirectedGraph<T>(this.nodeIdentity);\n        const nodeList = recur(startNodeIdentity, [initalNode])\n        const includeIdents = nodeList.map(t => this.nodeIdentity(t));\n        Array.from(this.nodes.values()).forEach(n => {\n            if (includeIdents.includes(this.nodeIdentity(n))) {\n                newGraph.insert(n)\n            }\n        });\n        newGraph.adjacency = this.subAdj(nodeList);\n        return newGraph\n    }\n\n    private subAdj(include: T[]): Array<Array<Edge>> {\n        const includeIdents = include.map(t => this.nodeIdentity(t));\n        const nodeIndices = Array.from(this.nodes.keys());\n\n        return this.adjacency.reduce<Array<Array<Edge>>>((carry, cur, index) => {\n            if (includeIdents.includes(nodeIndices[index])) {\n                return [...carry, cur.filter((_, index) => includeIdents.includes(nodeIndices[index]))]\n            } else {\n                return carry\n            }\n        }, [])\n    }\n}","import DirectedGraph from \"./directedGraph\";\nimport { CycleError } from \"./errors\";\n\n/**\n * # DirectedAcyclicGraph\n *\n * A DirectedAcyclicGraph is builds on a [[`DirectedGraph`]] but enforces acyclicality. You cannot add an edge to a DirectedAcyclicGraph that would create a cycle.\n *\n * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.\n */\nexport default class DirectedAcyclicGraph<T> extends DirectedGraph<T> {\n    private _topologicallySortedNodes?: Array<T>;\n    protected hasCycle = false; \n\n    /**\n     * Converts an existing directed graph into a directed acyclic graph.\n     * Throws a {@linkcode CycleError} if the graph attempting to be converted contains a cycle.\n     * @param graph The source directed graph to convert into a DAG\n     */\n    static fromDirectedGraph<T>(graph: DirectedGraph<T>): DirectedAcyclicGraph<T> {\n        if (!graph.isAcyclic()) {\n            throw new CycleError(\"Can't convert that graph to a DAG because it contains a cycle\")\n        }\n        const toRet = new DirectedAcyclicGraph<T>();\n\n        toRet.nodes = (graph as any).nodes\n        toRet.adjacency = (graph as any).adjacency\n\n        return toRet;\n    }\n\n    /**\n     * Adds an edge to the graph similarly to [[`DirectedGraph.addEdge`]] but maintains correctness of the acyclic graph.\n     * Thows a [[`CycleError`]] if adding the requested edge would create a cycle. \n     * Adding an edge invalidates the cache of topologically sorted nodes, rather than updating it.\n     * \n     * @param fromNodeIdentity The identity string of the node the edge should run from.\n     * @param toNodeIdentity The identity string of the node the edge should run to.\n     */\n    addEdge(fromNodeIdentity: string, toNodeIdentity: string) {\n        if (this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity)) {\n            throw new CycleError(`Can't add edge from ${fromNodeIdentity} to ${toNodeIdentity} it would create a cycle`)\n        }\n\n        // Invalidate cache of toposorted nodes\n        this._topologicallySortedNodes = undefined;\n        super.addEdge(fromNodeIdentity, toNodeIdentity, true)\n    }\n\n    /**\n     * Inserts a node into the graph and maintains topologic sort cache by prepending the node\n     * (since all newly created nodes have an [[ indegreeOfNode | indegree ]] of zero.)\n     * \n     * @param node The node to insert\n     */\n    insert(node: T): string {\n        if (this._topologicallySortedNodes) {\n            this._topologicallySortedNodes = [node, ...this._topologicallySortedNodes];\n        }\n        \n        return super.insert(node)\n    }\n\n    /**\n     * Topologically sort the nodes using Kahn's algorithim. Uses a cache which means that repeated calls should be O(1) after the first call. \n     * Non-cached calls are potentially expensive, Kahn's algorithim is O(|EdgeCount| + |NodeCount|). \n     * There may be more than one valid topological sort order for a single graph, \n     * so just because two graphs are the same does not mean that order of the resultant arrays will be.\n     * \n     * @returns An array of nodes sorted by the topological order.\n     */\n    topologicallySortedNodes(): Array<T> {\n        if (this._topologicallySortedNodes !== undefined) {\n            return this._topologicallySortedNodes;\n        }\n\n        const nodeIndices = Array.from(this.nodes.keys());\n        const nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(n => [n, this.indegreeOfNode(n)]))\n\n        const adjCopy = this.adjacency.map(a => [...a])\n\n        let toSearch = Array.from(nodeInDegrees).filter(pair => pair[1] === 0)\n\n        if (toSearch.length === this.nodes.size) {\n            const arrayOfNodes = Array.from(this.nodes.values());\n            this._topologicallySortedNodes = arrayOfNodes\n            return arrayOfNodes\n        }\n\n        let toReturn: Array<T> = []\n\n        while (toSearch.length) {\n            const n = (toSearch.pop() as [string, number]);\n            const curNode = (this.nodes.get(n[0]) as T);\n            toReturn.push(curNode);\n\n            (adjCopy[nodeIndices.indexOf(n[0])])?.forEach((edge, index) => {\n                if (edge > 0) {\n                    adjCopy[nodeIndices.indexOf(n[0])][index] = 0;\n                    const target = (nodeInDegrees.get(nodeIndices[index]) as number);\n                    nodeInDegrees.set(nodeIndices[index], target - 1)\n\n                    if ((target - 1) === 0) {\n                        toSearch.push([nodeIndices[index], 0])    \n                    }\n                }\n            })\n        }\n\n        // Update cache\n        this._topologicallySortedNodes = toReturn;\n\n        // we shouldn't need to account for the error case of there being a cycle because it shouldn't\n        // be possible to instantiate this class in a state (or put it in a state) where there is a cycle.\n\n        return toReturn\n    }\n\n    /**\n     * Given a starting node this returns a new [[`DirectedA`]] containing all the nodes that can be reached. \n     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.\n     * \n     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.\n     */\n    getSubGraphStartingFrom(startNodeIdentity: string): DirectedAcyclicGraph<T> {\n        return DirectedAcyclicGraph.fromDirectedGraph(super.getSubGraphStartingFrom(startNodeIdentity));\n    }\n}\n"],"names":[],"mappings":"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"}