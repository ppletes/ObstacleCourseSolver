/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * # NodeAlreadyExistsError
 *
 * This error is thrown when trying to create a node with the same identity as an existing node.
 *
 * @category Errors
 */
var NodeAlreadyExistsError = /** @class */ (function (_super) {
    __extends(NodeAlreadyExistsError, _super);
    function NodeAlreadyExistsError(newNode, oldNode, identity) {
        var _this = _super.call(this, JSON.stringify(newNode) + " shares an identity (" + identity + ") with " + JSON.stringify(oldNode)) || this;
        _this.newNode = newNode;
        _this.oldNode = oldNode;
        _this.identity = identity;
        _this.name = "NodeAlreadyExistsError";
        // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279
        Object.setPrototypeOf(_this, NodeAlreadyExistsError.prototype);
        return _this;
    }
    return NodeAlreadyExistsError;
}(Error));
/**
 * # NodeDoesntExistError
 * This error is thrown when trying to access a node in a graph by it's identity when that node doesn't exist
 *
 * @category Errors
 */
var NodeDoesntExistError = /** @class */ (function (_super) {
    __extends(NodeDoesntExistError, _super);
    function NodeDoesntExistError(identity) {
        var _this = _super.call(this, "A node with identity " + identity + " doesn't exist in the graph") || this;
        _this.identity = identity;
        _this.name = "NodeDoesntExistError";
        // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279
        Object.setPrototypeOf(_this, NodeDoesntExistError.prototype);
        return _this;
    }
    return NodeDoesntExistError;
}(Error));
/**
 * # CycleError
 *
 * This error is thrown when attempting to create or update a Directed Acyclic Graph that contains a cycle.
 *
 * @category Errors
 */
var CycleError = /** @class */ (function (_super) {
    __extends(CycleError, _super);
    function CycleError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = "CycleError";
        // This bs is due to a limitation of Typescript: https://github.com/facebook/jest/issues/8279
        Object.setPrototypeOf(_this, CycleError.prototype);
        return _this;
    }
    return CycleError;
}(Error));

/**
 * This is the default [[Graph.constructor | `nodeIdentity`]] function it is simply imported from [object-hash](https://www.npmjs.com/package/object-hash)
 */
var hash = require('object-hash');
/**
 * # Graph
 *
 * A `Graph` is is a simple undirected graph. On it's own it isn't too useful but it forms the basic functionality for the [[`DirectedGraph`]] and [[`DirectedAcyclicGraph`]].
 *
 * ## Creating a Graph
 *
 * You can create a graph to contain any type of node, for example:
 *
 * ```typescript
 * type NodeType = { a: Number, b: string }
 * const graph = new Graph<NodeType>()
 *
 * // Add a node of the defined type
 * graph.insert({ a: 10, b: 'string' })
 * ```
 *
 * ### Defining a custom node identity
 *
 * When you create a graph you likely want to create include a custom `nodeIdentity` function.
 * This function tells the graph how to uniquely identify nodes in a graph,
 * default is to simply use an [[hash]] which means that functionality like [[`replace`]] will not work.
 *
 * ```typescript
 * type NodeType = { count: number, name: string }
 * const graph = new Graph<NodeType>((n) => n.name)
 *
 * // Add a node
 * graph.insert({ count: 5, name: 'node1' })
 * // This will throw an error even though `count` is different because they share a name.
 * graph.insert({ count: 20, name: 'node1' })
 * ```
 *
 * ### Adding an edge
 *
 * Graphs without edges aren't very useful. Inserting edges is done using the node identity string returned by the node identity function.
 *
 * ```typescript
 * const node1: string = graph.insert({ count: 5, name: 'node1' })
 * const node2: string = graph.insert({ count: 20, name: 'node2' })
 *
 * graph.addEdge(node1, node2)
 *
 * // This will throw an error since there is no node with the later name.
 * graph.addEdge(node1, 'not a real node')
 * ```
 *
 * In an undirected graph the order in which you input the node names doesn't matter,
 * but in directed graphs the "from node" comes first and the "to node" will come second.
 *
 * ### Replacing a node
 *
 * If a node already exists you can update it using [[`replace`]]. `nodeIdentity(newNode)` must be equal to `nodeIdentity(oldNode)`.
 *
 * ```typescript
 * const node1: string = graph.insert({ count: 5, name: 'node1' })
 * const node2: string = graph.insert({ count: 20, name: 'node2' })
 *
 * // This will work because the name has not changed.
 * graph.replace({ count: 15, name: 'node1' })
 *
 * // This will not work because the name has changed.
 * graph.replace({ count: 20, name: 'node3' })
 * ```
 *
 * [[`replace`]] will throw a [[`NodeDoesntExistError`]] exception if you are trying to replace a node that is missing from the graph.
 *
 * ### Upsert
 *
 * Often you will want to create a node node if it doesn't exist and update it does. This can be achieved using [[`upsert`]].
 *
 * ```typescript
 * const node1: string = graph.insert({ count: 5, name: 'node1' })
 *
 * // Both of these will work, the first updating node1 and the second creating a node.
 * const node2: string = graph.upsert({ count: 15, name: 'node1' })
 * const node3: string = graph.upsert({ count: 25, name: 'node3' })
 * ```
 *
 * [[`upsert`]] always return the node identity string of the inserted or updated node. At presented there is no way to tell if the node was created or updated.
 *
 * @typeParam T  `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
var Graph = /** @class */ (function () {
    function Graph(nodeIdentity) {
        if (nodeIdentity === void 0) { nodeIdentity = function (node) { return hash(node); }; }
        this.nodes = new Map();
        this.adjacency = [];
        this.nodeIdentity = nodeIdentity;
    }
    /**
     * Add a node to the graph if it doesn't already exist. If it does, throw a [[`NodeAlreadyExistsError`]].
     *
     * @param node The node to be added
     * @returns A `string` that is the identity of the newly inserted node. This is created by applying the [[constructor | `nodeIdentity`]].
     */
    Graph.prototype.insert = function (node) {
        var isOverwrite = this.nodes.has(this.nodeIdentity(node));
        if (isOverwrite) {
            throw new NodeAlreadyExistsError(node, this.nodes.get(this.nodeIdentity(node)), this.nodeIdentity(node));
        }
        this.nodes.set(this.nodeIdentity(node), node);
        this.adjacency.map(function (adj) { return adj.push(0); });
        this.adjacency.push(new Array(this.adjacency.length + 1).fill(0));
        return this.nodeIdentity(node);
    };
    /**
     * This replaces an existing node in the graph with an updated version.
     * Throws a [[`NodeDoesNotExistsError`]] if no node with the same identity already exists.
     *
     * __Caveat_:_ The default identity function means that this will never work since if the node changes it will have a different [[`hash`]].
     *
     * @param node The new node that is replacing the old one.
     */
    Graph.prototype.replace = function (node) {
        var isOverwrite = this.nodes.has(this.nodeIdentity(node));
        if (!isOverwrite) {
            throw new NodeDoesntExistError(this.nodeIdentity(node));
        }
        this.nodes.set(this.nodeIdentity(node), node);
    };
    /**
     * This essentially combines the behavior of [[`insert`]] and [[`replace`]].
     * If the node doesn't exist, create it. If the node already exists, replace it with the updated version.
     *
     * @param node The node to insert or update
     * @returns The identity string of the node inserted or updated.
     */
    Graph.prototype.upsert = function (node) {
        var isOverwrite = this.nodes.has(this.nodeIdentity(node));
        this.nodes.set(this.nodeIdentity(node), node);
        if (!isOverwrite) {
            this.adjacency.map(function (adj) { return adj.push(0); });
            this.adjacency.push(new Array(this.adjacency.length + 1).fill(0));
        }
        return this.nodeIdentity(node);
    };
    /**
     * Create an edge between two nodes in the graph.
     * Throws a [[`NodeDoesNotExistsError`]] if no either of the nodes you are attempting to connect do not exist.
     *
     * @param node1Identity The first node to connect (in [[`DirectedGraph`]]s and [[`DirectedAcyclicGraph`]]s this is the `from` node.)
     * @param node2Identity The second node to connect (in [[`DirectedGraph`]]s and [[`DirectedAcyclicGraph`]]s this is the `to` node)
     */
    Graph.prototype.addEdge = function (node1Identity, node2Identity) {
        var node1Exists = this.nodes.has(node1Identity);
        var node2Exists = this.nodes.has(node2Identity);
        if (!node1Exists) {
            throw new NodeDoesntExistError(node1Identity);
        }
        if (!node2Exists) {
            throw new NodeDoesntExistError(node2Identity);
        }
        var node1Index = Array.from(this.nodes.keys()).indexOf(node1Identity);
        var node2Index = Array.from(this.nodes.keys()).indexOf(node2Identity);
        this.adjacency[node1Index][node2Index] = 1;
    };
    /**
     * This simply returns all the nodes stored in the graph
     *
     * @param compareFunc An optional function that indicates the sort order of the returned array
     */
    Graph.prototype.getNodes = function (compareFunc) {
        var temp = Array.from(this.nodes.values());
        if (compareFunc) {
            return temp.sort(compareFunc);
        }
        return temp;
    };
    return Graph;
}());

/**
 * # DirectedGraph
 *
 * A DirectedGraph is similar a [[`Graph`]] but with additional functionality.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
var DirectedGraph = /** @class */ (function (_super) {
    __extends(DirectedGraph, _super);
    function DirectedGraph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns `true` if there are no cycles in the graph.
     * This relies on a cached value so calling it multiple times without adding edges to the graph should be O(1) after the first call.
     * Non-cached calls are potentially expensive, the implementation is based on Kahn's algorithim which is O(|EdgeCount| + |NodeCount|).
     */
    DirectedGraph.prototype.isAcyclic = function () {
        var _this = this;
        if (this.hasCycle !== undefined) {
            return !this.hasCycle;
        }
        var nodeIndices = Array.from(this.nodes.keys());
        var nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(function (n) { return [n, _this.indegreeOfNode(n)]; }));
        var toSearch = Array.from(nodeInDegrees).filter(function (pair) { return pair[1] === 0; });
        var visitedNodes = 0;
        while (toSearch.length > 0) {
            var cur = toSearch.pop();
            if (!cur) {
                continue;
            }
            var nodeIndex = nodeIndices.indexOf(cur[0]);
            this.adjacency[nodeIndex].forEach(function (hasAdj, index) {
                if (hasAdj === 1) {
                    var currentInDegree = nodeInDegrees.get(nodeIndices[index]);
                    if (currentInDegree !== undefined) {
                        nodeInDegrees.set(nodeIndices[index], currentInDegree - 1);
                        if ((currentInDegree - 1) === 0) {
                            toSearch.push([nodeIndices[index], currentInDegree - 1]);
                        }
                    }
                }
            });
            visitedNodes++;
        }
        this.hasCycle = !(visitedNodes === this.nodes.size);
        return visitedNodes === this.nodes.size;
    };
    /**
     * The indegree of a node is the number of edges that point to it. This will always be an integer.
     *
     * Throws a [[`NodeDoesntExistError`]] the node does not exist.
     *
     * @param nodeID The string of the node identity of the node to calculate indegree for.
     */
    DirectedGraph.prototype.indegreeOfNode = function (nodeID) {
        var nodeIdentities = Array.from(this.nodes.keys());
        var indexOfNode = nodeIdentities.indexOf(nodeID);
        if (indexOfNode === -1) {
            throw new NodeDoesntExistError(nodeID);
        }
        return this.adjacency.reduce(function (carry, row) {
            return carry + ((row[indexOfNode] > 0) ? 1 : 0);
        }, 0);
    };
    /**
     * Add a directed edge to the graph.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     * @param skipUpdatingCyclicality This boolean indicates if the cache of the cyclicality of the graph should be updated.
     * If `false` is passed the cached will be invalidated because we can not assure that a cycle has not been created.
     */
    DirectedGraph.prototype.addEdge = function (fromNodeIdentity, toNodeIdentity, skipUpdatingCyclicality) {
        if (skipUpdatingCyclicality === void 0) { skipUpdatingCyclicality = false; }
        if (!this.hasCycle && !skipUpdatingCyclicality) {
            this.hasCycle = this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity);
        }
        else if (skipUpdatingCyclicality) {
            this.hasCycle = undefined;
        }
        _super.prototype.addEdge.call(this, fromNodeIdentity, toNodeIdentity);
    };
    /**
     * Depth first search to see if one node is reachable from another following the directed edges.
     *
     * __Caveat:__ This will return false if `startNode` and `endNode` are the same node and the is not a cycle or a loop edge connecting them.
     *
     * @param startNode The string identity of the node to start at.
     * @param endNode The string identity of the node we are attempting to reach.
     */
    DirectedGraph.prototype.canReachFrom = function (startNode, endNode) {
        var _this = this;
        var nodeIdentities = Array.from(this.nodes.keys());
        var startNodeIndex = nodeIdentities.indexOf(startNode);
        var endNodeIndex = nodeIdentities.indexOf(endNode);
        if (this.adjacency[startNodeIndex][endNodeIndex] > 0) {
            return true;
        }
        return this.adjacency[startNodeIndex].reduce(function (carry, edge, index) {
            if (carry || (edge < 1)) {
                return carry;
            }
            return _this.canReachFrom(nodeIdentities[index], endNode);
        }, false);
    };
    /**
     * Checks if adding the specified edge would create a cycle.
     * Returns true in O(1) if the graph already contains a known cycle, or if `fromNodeIdentity` and `toNodeIdentity` are the same.
     *
     * @param fromNodeIdentity The string identity of the node the edge is from.
     * @param toNodeIdentity The string identity of the node the edge is to.
     */
    DirectedGraph.prototype.wouldAddingEdgeCreateCyle = function (fromNodeIdentity, toNodeIdentity) {
        return this.hasCycle || fromNodeIdentity === toNodeIdentity || this.canReachFrom(toNodeIdentity, fromNodeIdentity);
    };
    /**
     * Given a starting node this returns a new [[`DirectedGraph`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    DirectedGraph.prototype.getSubGraphStartingFrom = function (startNodeIdentity) {
        var _this = this;
        var nodeIndices = Array.from(this.nodes.keys());
        var initalNode = this.nodes.get(startNodeIdentity);
        if (!initalNode) {
            throw new NodeDoesntExistError(startNodeIdentity);
        }
        var recur = function (startNodeIdentity, nodesToInclude) {
            var toReturn = __spreadArrays(nodesToInclude);
            var nodeIndex = nodeIndices.indexOf(startNodeIdentity);
            _this.adjacency[nodeIndex].forEach(function (hasAdj, index) {
                if (hasAdj === 1 && !nodesToInclude.find(function (n) { return _this.nodeIdentity(n) === nodeIndices[index]; })) {
                    var newNode = _this.nodes.get(nodeIndices[index]);
                    if (newNode) {
                        toReturn = __spreadArrays(recur(nodeIndices[index], toReturn), [newNode]);
                    }
                }
            });
            return toReturn;
        };
        var newGraph = new DirectedGraph(this.nodeIdentity);
        var nodeList = recur(startNodeIdentity, [initalNode]);
        var includeIdents = nodeList.map(function (t) { return _this.nodeIdentity(t); });
        Array.from(this.nodes.values()).forEach(function (n) {
            if (includeIdents.includes(_this.nodeIdentity(n))) {
                newGraph.insert(n);
            }
        });
        newGraph.adjacency = this.subAdj(nodeList);
        return newGraph;
    };
    DirectedGraph.prototype.subAdj = function (include) {
        var _this = this;
        var includeIdents = include.map(function (t) { return _this.nodeIdentity(t); });
        var nodeIndices = Array.from(this.nodes.keys());
        return this.adjacency.reduce(function (carry, cur, index) {
            if (includeIdents.includes(nodeIndices[index])) {
                return __spreadArrays(carry, [cur.filter(function (_, index) { return includeIdents.includes(nodeIndices[index]); })]);
            }
            else {
                return carry;
            }
        }, []);
    };
    return DirectedGraph;
}(Graph));

/**
 * # DirectedAcyclicGraph
 *
 * A DirectedAcyclicGraph is builds on a [[`DirectedGraph`]] but enforces acyclicality. You cannot add an edge to a DirectedAcyclicGraph that would create a cycle.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
var DirectedAcyclicGraph = /** @class */ (function (_super) {
    __extends(DirectedAcyclicGraph, _super);
    function DirectedAcyclicGraph() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasCycle = false;
        return _this;
    }
    /**
     * Converts an existing directed graph into a directed acyclic graph.
     * Throws a {@linkcode CycleError} if the graph attempting to be converted contains a cycle.
     * @param graph The source directed graph to convert into a DAG
     */
    DirectedAcyclicGraph.fromDirectedGraph = function (graph) {
        if (!graph.isAcyclic()) {
            throw new CycleError("Can't convert that graph to a DAG because it contains a cycle");
        }
        var toRet = new DirectedAcyclicGraph();
        toRet.nodes = graph.nodes;
        toRet.adjacency = graph.adjacency;
        return toRet;
    };
    /**
     * Adds an edge to the graph similarly to [[`DirectedGraph.addEdge`]] but maintains correctness of the acyclic graph.
     * Thows a [[`CycleError`]] if adding the requested edge would create a cycle.
     * Adding an edge invalidates the cache of topologically sorted nodes, rather than updating it.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     */
    DirectedAcyclicGraph.prototype.addEdge = function (fromNodeIdentity, toNodeIdentity) {
        if (this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity)) {
            throw new CycleError("Can't add edge from " + fromNodeIdentity + " to " + toNodeIdentity + " it would create a cycle");
        }
        // Invalidate cache of toposorted nodes
        this._topologicallySortedNodes = undefined;
        _super.prototype.addEdge.call(this, fromNodeIdentity, toNodeIdentity, true);
    };
    /**
     * Inserts a node into the graph and maintains topologic sort cache by prepending the node
     * (since all newly created nodes have an [[ indegreeOfNode | indegree ]] of zero.)
     *
     * @param node The node to insert
     */
    DirectedAcyclicGraph.prototype.insert = function (node) {
        if (this._topologicallySortedNodes) {
            this._topologicallySortedNodes = __spreadArrays([node], this._topologicallySortedNodes);
        }
        return _super.prototype.insert.call(this, node);
    };
    /**
     * Topologically sort the nodes using Kahn's algorithim. Uses a cache which means that repeated calls should be O(1) after the first call.
     * Non-cached calls are potentially expensive, Kahn's algorithim is O(|EdgeCount| + |NodeCount|).
     * There may be more than one valid topological sort order for a single graph,
     * so just because two graphs are the same does not mean that order of the resultant arrays will be.
     *
     * @returns An array of nodes sorted by the topological order.
     */
    DirectedAcyclicGraph.prototype.topologicallySortedNodes = function () {
        var _this = this;
        var _a;
        if (this._topologicallySortedNodes !== undefined) {
            return this._topologicallySortedNodes;
        }
        var nodeIndices = Array.from(this.nodes.keys());
        var nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(function (n) { return [n, _this.indegreeOfNode(n)]; }));
        var adjCopy = this.adjacency.map(function (a) { return __spreadArrays(a); });
        var toSearch = Array.from(nodeInDegrees).filter(function (pair) { return pair[1] === 0; });
        if (toSearch.length === this.nodes.size) {
            var arrayOfNodes = Array.from(this.nodes.values());
            this._topologicallySortedNodes = arrayOfNodes;
            return arrayOfNodes;
        }
        var toReturn = [];
        var _loop_1 = function () {
            var n = toSearch.pop();
            var curNode = this_1.nodes.get(n[0]);
            toReturn.push(curNode);
            (_a = (adjCopy[nodeIndices.indexOf(n[0])])) === null || _a === void 0 ? void 0 : _a.forEach(function (edge, index) {
                if (edge > 0) {
                    adjCopy[nodeIndices.indexOf(n[0])][index] = 0;
                    var target = nodeInDegrees.get(nodeIndices[index]);
                    nodeInDegrees.set(nodeIndices[index], target - 1);
                    if ((target - 1) === 0) {
                        toSearch.push([nodeIndices[index], 0]);
                    }
                }
            });
        };
        var this_1 = this;
        while (toSearch.length) {
            _loop_1();
        }
        // Update cache
        this._topologicallySortedNodes = toReturn;
        // we shouldn't need to account for the error case of there being a cycle because it shouldn't
        // be possible to instantiate this class in a state (or put it in a state) where there is a cycle.
        return toReturn;
    };
    /**
     * Given a starting node this returns a new [[`DirectedA`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    DirectedAcyclicGraph.prototype.getSubGraphStartingFrom = function (startNodeIdentity) {
        return DirectedAcyclicGraph.fromDirectedGraph(_super.prototype.getSubGraphStartingFrom.call(this, startNodeIdentity));
    };
    return DirectedAcyclicGraph;
}(DirectedGraph));

export { Graph, DirectedGraph, DirectedAcyclicGraph };
//# sourceMappingURL=typescript-graph.es5.js.map
