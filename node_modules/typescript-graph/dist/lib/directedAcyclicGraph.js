"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var directedGraph_1 = require("./directedGraph");
var errors_1 = require("./errors");
/**
 * # DirectedAcyclicGraph
 *
 * A DirectedAcyclicGraph is builds on a [[`DirectedGraph`]] but enforces acyclicality. You cannot add an edge to a DirectedAcyclicGraph that would create a cycle.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
var DirectedAcyclicGraph = /** @class */ (function (_super) {
    __extends(DirectedAcyclicGraph, _super);
    function DirectedAcyclicGraph() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasCycle = false;
        return _this;
    }
    /**
     * Converts an existing directed graph into a directed acyclic graph.
     * Throws a {@linkcode CycleError} if the graph attempting to be converted contains a cycle.
     * @param graph The source directed graph to convert into a DAG
     */
    DirectedAcyclicGraph.fromDirectedGraph = function (graph) {
        if (!graph.isAcyclic()) {
            throw new errors_1.CycleError("Can't convert that graph to a DAG because it contains a cycle");
        }
        var toRet = new DirectedAcyclicGraph();
        toRet.nodes = graph.nodes;
        toRet.adjacency = graph.adjacency;
        return toRet;
    };
    /**
     * Adds an edge to the graph similarly to [[`DirectedGraph.addEdge`]] but maintains correctness of the acyclic graph.
     * Thows a [[`CycleError`]] if adding the requested edge would create a cycle.
     * Adding an edge invalidates the cache of topologically sorted nodes, rather than updating it.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     */
    DirectedAcyclicGraph.prototype.addEdge = function (fromNodeIdentity, toNodeIdentity) {
        if (this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity)) {
            throw new errors_1.CycleError("Can't add edge from " + fromNodeIdentity + " to " + toNodeIdentity + " it would create a cycle");
        }
        // Invalidate cache of toposorted nodes
        this._topologicallySortedNodes = undefined;
        _super.prototype.addEdge.call(this, fromNodeIdentity, toNodeIdentity, true);
    };
    /**
     * Inserts a node into the graph and maintains topologic sort cache by prepending the node
     * (since all newly created nodes have an [[ indegreeOfNode | indegree ]] of zero.)
     *
     * @param node The node to insert
     */
    DirectedAcyclicGraph.prototype.insert = function (node) {
        if (this._topologicallySortedNodes) {
            this._topologicallySortedNodes = __spreadArrays([node], this._topologicallySortedNodes);
        }
        return _super.prototype.insert.call(this, node);
    };
    /**
     * Topologically sort the nodes using Kahn's algorithim. Uses a cache which means that repeated calls should be O(1) after the first call.
     * Non-cached calls are potentially expensive, Kahn's algorithim is O(|EdgeCount| + |NodeCount|).
     * There may be more than one valid topological sort order for a single graph,
     * so just because two graphs are the same does not mean that order of the resultant arrays will be.
     *
     * @returns An array of nodes sorted by the topological order.
     */
    DirectedAcyclicGraph.prototype.topologicallySortedNodes = function () {
        var _this = this;
        var _a;
        if (this._topologicallySortedNodes !== undefined) {
            return this._topologicallySortedNodes;
        }
        var nodeIndices = Array.from(this.nodes.keys());
        var nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(function (n) { return [n, _this.indegreeOfNode(n)]; }));
        var adjCopy = this.adjacency.map(function (a) { return __spreadArrays(a); });
        var toSearch = Array.from(nodeInDegrees).filter(function (pair) { return pair[1] === 0; });
        if (toSearch.length === this.nodes.size) {
            var arrayOfNodes = Array.from(this.nodes.values());
            this._topologicallySortedNodes = arrayOfNodes;
            return arrayOfNodes;
        }
        var toReturn = [];
        var _loop_1 = function () {
            var n = toSearch.pop();
            var curNode = this_1.nodes.get(n[0]);
            toReturn.push(curNode);
            (_a = (adjCopy[nodeIndices.indexOf(n[0])])) === null || _a === void 0 ? void 0 : _a.forEach(function (edge, index) {
                if (edge > 0) {
                    adjCopy[nodeIndices.indexOf(n[0])][index] = 0;
                    var target = nodeInDegrees.get(nodeIndices[index]);
                    nodeInDegrees.set(nodeIndices[index], target - 1);
                    if ((target - 1) === 0) {
                        toSearch.push([nodeIndices[index], 0]);
                    }
                }
            });
        };
        var this_1 = this;
        while (toSearch.length) {
            _loop_1();
        }
        // Update cache
        this._topologicallySortedNodes = toReturn;
        // we shouldn't need to account for the error case of there being a cycle because it shouldn't
        // be possible to instantiate this class in a state (or put it in a state) where there is a cycle.
        return toReturn;
    };
    /**
     * Given a starting node this returns a new [[`DirectedA`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    DirectedAcyclicGraph.prototype.getSubGraphStartingFrom = function (startNodeIdentity) {
        return DirectedAcyclicGraph.fromDirectedGraph(_super.prototype.getSubGraphStartingFrom.call(this, startNodeIdentity));
    };
    return DirectedAcyclicGraph;
}(directedGraph_1.default));
exports.default = DirectedAcyclicGraph;
//# sourceMappingURL=directedAcyclicGraph.js.map