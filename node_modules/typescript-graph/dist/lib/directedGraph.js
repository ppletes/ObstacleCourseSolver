"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var graph_1 = require("./graph");
/**
 * # DirectedGraph
 *
 * A DirectedGraph is similar a [[`Graph`]] but with additional functionality.
 *
 * @typeParam T `T` is the node type of the graph. Nodes can be anything in all the included examples they are simple objects.
 */
var DirectedGraph = /** @class */ (function (_super) {
    __extends(DirectedGraph, _super);
    function DirectedGraph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns `true` if there are no cycles in the graph.
     * This relies on a cached value so calling it multiple times without adding edges to the graph should be O(1) after the first call.
     * Non-cached calls are potentially expensive, the implementation is based on Kahn's algorithim which is O(|EdgeCount| + |NodeCount|).
     */
    DirectedGraph.prototype.isAcyclic = function () {
        var _this = this;
        if (this.hasCycle !== undefined) {
            return !this.hasCycle;
        }
        var nodeIndices = Array.from(this.nodes.keys());
        var nodeInDegrees = new Map(Array.from(this.nodes.keys()).map(function (n) { return [n, _this.indegreeOfNode(n)]; }));
        var toSearch = Array.from(nodeInDegrees).filter(function (pair) { return pair[1] === 0; });
        var visitedNodes = 0;
        while (toSearch.length > 0) {
            var cur = toSearch.pop();
            if (!cur) {
                continue;
            }
            var nodeIndex = nodeIndices.indexOf(cur[0]);
            this.adjacency[nodeIndex].forEach(function (hasAdj, index) {
                if (hasAdj === 1) {
                    var currentInDegree = nodeInDegrees.get(nodeIndices[index]);
                    if (currentInDegree !== undefined) {
                        nodeInDegrees.set(nodeIndices[index], currentInDegree - 1);
                        if ((currentInDegree - 1) === 0) {
                            toSearch.push([nodeIndices[index], currentInDegree - 1]);
                        }
                    }
                }
            });
            visitedNodes++;
        }
        this.hasCycle = !(visitedNodes === this.nodes.size);
        return visitedNodes === this.nodes.size;
    };
    /**
     * The indegree of a node is the number of edges that point to it. This will always be an integer.
     *
     * Throws a [[`NodeDoesntExistError`]] the node does not exist.
     *
     * @param nodeID The string of the node identity of the node to calculate indegree for.
     */
    DirectedGraph.prototype.indegreeOfNode = function (nodeID) {
        var nodeIdentities = Array.from(this.nodes.keys());
        var indexOfNode = nodeIdentities.indexOf(nodeID);
        if (indexOfNode === -1) {
            throw new errors_1.NodeDoesntExistError(nodeID);
        }
        return this.adjacency.reduce(function (carry, row) {
            return carry + ((row[indexOfNode] > 0) ? 1 : 0);
        }, 0);
    };
    /**
     * Add a directed edge to the graph.
     *
     * @param fromNodeIdentity The identity string of the node the edge should run from.
     * @param toNodeIdentity The identity string of the node the edge should run to.
     * @param skipUpdatingCyclicality This boolean indicates if the cache of the cyclicality of the graph should be updated.
     * If `false` is passed the cached will be invalidated because we can not assure that a cycle has not been created.
     */
    DirectedGraph.prototype.addEdge = function (fromNodeIdentity, toNodeIdentity, skipUpdatingCyclicality) {
        if (skipUpdatingCyclicality === void 0) { skipUpdatingCyclicality = false; }
        if (!this.hasCycle && !skipUpdatingCyclicality) {
            this.hasCycle = this.wouldAddingEdgeCreateCyle(fromNodeIdentity, toNodeIdentity);
        }
        else if (skipUpdatingCyclicality) {
            this.hasCycle = undefined;
        }
        _super.prototype.addEdge.call(this, fromNodeIdentity, toNodeIdentity);
    };
    /**
     * Depth first search to see if one node is reachable from another following the directed edges.
     *
     * __Caveat:__ This will return false if `startNode` and `endNode` are the same node and the is not a cycle or a loop edge connecting them.
     *
     * @param startNode The string identity of the node to start at.
     * @param endNode The string identity of the node we are attempting to reach.
     */
    DirectedGraph.prototype.canReachFrom = function (startNode, endNode) {
        var _this = this;
        var nodeIdentities = Array.from(this.nodes.keys());
        var startNodeIndex = nodeIdentities.indexOf(startNode);
        var endNodeIndex = nodeIdentities.indexOf(endNode);
        if (this.adjacency[startNodeIndex][endNodeIndex] > 0) {
            return true;
        }
        return this.adjacency[startNodeIndex].reduce(function (carry, edge, index) {
            if (carry || (edge < 1)) {
                return carry;
            }
            return _this.canReachFrom(nodeIdentities[index], endNode);
        }, false);
    };
    /**
     * Checks if adding the specified edge would create a cycle.
     * Returns true in O(1) if the graph already contains a known cycle, or if `fromNodeIdentity` and `toNodeIdentity` are the same.
     *
     * @param fromNodeIdentity The string identity of the node the edge is from.
     * @param toNodeIdentity The string identity of the node the edge is to.
     */
    DirectedGraph.prototype.wouldAddingEdgeCreateCyle = function (fromNodeIdentity, toNodeIdentity) {
        return this.hasCycle || fromNodeIdentity === toNodeIdentity || this.canReachFrom(toNodeIdentity, fromNodeIdentity);
    };
    /**
     * Given a starting node this returns a new [[`DirectedGraph`]] containing all the nodes that can be reached.
     * Throws a [[`NodeDoesntExistError`]] if the start node does not exist.
     *
     * @param startNodeIdentity The string identity of the node from which the subgraph search should start.
     */
    DirectedGraph.prototype.getSubGraphStartingFrom = function (startNodeIdentity) {
        var _this = this;
        var nodeIndices = Array.from(this.nodes.keys());
        var initalNode = this.nodes.get(startNodeIdentity);
        if (!initalNode) {
            throw new errors_1.NodeDoesntExistError(startNodeIdentity);
        }
        var recur = function (startNodeIdentity, nodesToInclude) {
            var toReturn = __spreadArrays(nodesToInclude);
            var nodeIndex = nodeIndices.indexOf(startNodeIdentity);
            _this.adjacency[nodeIndex].forEach(function (hasAdj, index) {
                if (hasAdj === 1 && !nodesToInclude.find(function (n) { return _this.nodeIdentity(n) === nodeIndices[index]; })) {
                    var newNode = _this.nodes.get(nodeIndices[index]);
                    if (newNode) {
                        toReturn = __spreadArrays(recur(nodeIndices[index], toReturn), [newNode]);
                    }
                }
            });
            return toReturn;
        };
        var newGraph = new DirectedGraph(this.nodeIdentity);
        var nodeList = recur(startNodeIdentity, [initalNode]);
        var includeIdents = nodeList.map(function (t) { return _this.nodeIdentity(t); });
        Array.from(this.nodes.values()).forEach(function (n) {
            if (includeIdents.includes(_this.nodeIdentity(n))) {
                newGraph.insert(n);
            }
        });
        newGraph.adjacency = this.subAdj(nodeList);
        return newGraph;
    };
    DirectedGraph.prototype.subAdj = function (include) {
        var _this = this;
        var includeIdents = include.map(function (t) { return _this.nodeIdentity(t); });
        var nodeIndices = Array.from(this.nodes.keys());
        return this.adjacency.reduce(function (carry, cur, index) {
            if (includeIdents.includes(nodeIndices[index])) {
                return __spreadArrays(carry, [cur.filter(function (_, index) { return includeIdents.includes(nodeIndices[index]); })]);
            }
            else {
                return carry;
            }
        }, []);
    };
    return DirectedGraph;
}(graph_1.default));
exports.default = DirectedGraph;
//# sourceMappingURL=directedGraph.js.map